"""
Rules to align PacBio reads to a given reference assembly and summarize
alignments.
"""
import math

localrules: assign_batches, align_reads

# Make a list of batches to split reads into.
BATCHES = list(range(int(config.get("batches", "1"))))

# User-defined file of alignments with one absolute path to a BAM per line.
ALIGNMENTS = config.get("alignments", "alignments.fofn")
ALIGNMENTS_DIR = config.get("alignments_dir", "alignments")

# Create a list of BAM files for downstream analysis.
rule align_reads:
    input: expand("%s/{batch_id}.bam" % ALIGNMENTS_DIR, batch_id=BATCHES)
    output: ALIGNMENTS
    params: sge_opts=""
    shell: "for alignment in {input}; do echo `pwd`/$alignment; done > {output}"

# Plot alignment lengths.
rule plot_alignment_summaries:
    input: "alignment_lengths.tab"
    output: "alignment_lengths.pdf"
    params: sge_opts="-l mfree=8G"
    shell: "Rscript plot_read_lengths_by_type.R {input} {output}"

# Collect summary of aligned read lengths.
rule collect_alignment_summaries:
    input: expand("alignment_lengths/{batch_id}.tab", batch_id=BATCHES)
    output: "alignment_lengths.tab"
    params: sge_opts=""
    shell: """awk 'OFS="\\t" {{ if (NR == 1) {{ print "alignment_status","subread_length","aligned_length" }} print }}' {input} > {output}"""

# Summarize alignments by length.
# TODO: get subread lengths at the same time as the aligned lengths.
rule get_subread_and_alignment_lengths:
    input: "%s/{batch_id}.bam" % ALIGNMENTS_DIR
    output: "alignment_lengths/{batch_id}.tab"
    params: sge_opts="", mapping_quality_threshold="30"
    shell:
        "mkdir -p {TMP_DIR}; "
        """samtools view {input} | awk 'OFS="\\t" {{ if ($3 == "*" || $5 >= {params.mapping_quality_threshold}) {{ num_of_pieces = split($1, pieces, "/"); num_of_coords = split(pieces[3], coords, "_"); subread_length = coords[2] - coords[1]; if ($3 == "*") {{ print "unmapped",subread_length,length($10) }} else if ($5 >= 30) {{ print "mapped",subread_length,$9 }} }} }}' > {TMP_DIR}/lengths.`basename {output}`; """
        "rsync --remove-source-files {TMP_DIR}/lengths.`basename {output}` {output}; "

# Sync input reads and reference assembly to local disk, align reads, sort
# output, and write final BAM to shared disk.
rule align_batch:
    input: reads="%s_reads/{batch_id}.fofn" % ALIGNMENTS_DIR, reference=config["reference"], suffix=config.get("suffix_array", "%s.sa" % config["reference"]), ctab=config.get("ctab", "%s.ctab" % config["reference"])
    output: protected("%s/{batch_id}.bam" % ALIGNMENTS_DIR)
    params: sge_opts="-l disk_free=200G -l mfree=3.25G -pe serial 12 -N align_batch_{batch_id}", threads="10", samtools_threads="2", samtools_memory="4G", bwlimit="30000", alignment_parameters=config["alignment"]["alignment_parameters"]
    shell:
        "mkdir -p {TMP_DIR}/{wildcards.batch_id}; "
        "cd {TMP_DIR}/{wildcards.batch_id}; "
        "set -o pipefail; "
        "set -e; "
        "{BLASR_BIN} {CWD}/{input.reads} {input.reference} -unaligned /dev/null -out /dev/stdout -sam -sa {input.suffix} -ctab {input.ctab} -nproc {params.threads} -clipping subread {params.alignment_parameters} | samtools sort -@ {params.samtools_threads} -m {params.samtools_memory} -O bam -T {wildcards.batch_id} -o {wildcards.batch_id}.bam -; "
        "samtools index {wildcards.batch_id}.bam; "
        "rsync --bwlimit={params.bwlimit} --remove-source-files -W {wildcards.batch_id}.bam* {CWD}/`dirname {output}`/; "
        "rm -rf {TMP_DIR}/{wildcards.batch_id}"

# Divide input reads into batches for alignment.
rule assign_batches:
    input: config["reads"]
    output: "%s_reads/{batch_id}.fofn" % ALIGNMENTS_DIR
    params: sge_opts=""
    run:
        output_dir = os.path.dirname(output[0])

        with open(input[0], "r") as fh:
            input_files = [os.path.realpath(line.rstrip()) for line in fh]

        files_per_batch = int(math.ceil(len(input_files) / float(len(BATCHES))))
        start = int(wildcards["batch_id"]) * files_per_batch
        end = min(start + files_per_batch, len(input_files))

        with open(output[0], "w") as oh:
            for input_file in input_files[start:end]:
                oh.write("%s\n" % input_file)
