"""
Rules to identify SV candidates from read alignments confirmation by for local
assembly.
"""
import os

# Load alignments.
if config.get("alignments"):
    with open(config["alignments"], "r") as fh:
        ALIGNMENTS = sorted([line.rstrip() for line in fh])

    PATHS_BY_ALIGNMENT_NAME = dict([(os.path.basename(alignment).rstrip(".bam"), alignment) for alignment in ALIGNMENTS])
    ALIGNMENT_NAMES = sorted(PATHS_BY_ALIGNMENT_NAME.keys())
else:
    ALIGNMENT_NAMES = []

def _get_bam_path_for_batch(wildcards):
    return PATHS_BY_ALIGNMENT_NAME.get(wildcards.alignment_name)

# Annotate assembly candidates with coverage.
rule detect_svs:
    input: "assembly_candidates_with_coverage.bed"
    output: "filtered_assembly_candidates_with_coverage.bed"
    params: sge_opts="", max_coverage=str(config["detection"]["max_coverage"]), max_length=str(config["detection"]["max_candidate_length"])
    run:
        if config["detection"].get("regions_to_exclude"):
            shell("bedtools intersect -a {input} -b %s -wa -v | awk '$4 <= {params.max_coverage} && $3 - $2 <= {params.max_length}' > {output}" % config["detection"].get("regions_to_exclude"))
        else:
            shell("awk '$4 <= {params.max_coverage} && $3 - $2 <= {params.max_length}' {input} > {output}")

# Annotate assembly candidates with coverage.
rule annotate_coverage_for_candidates:
    input: candidates="assembly_candidates.bed", coverage="coverage.bed"
    output: "assembly_candidates_with_coverage.bed"
    params: sge_opts=""
    shell: "bedtools intersect -a {input.candidates} -b {input.coverage} -sorted -wao | groupBy -i stdin -g 1,2,3 -c 7 -o mean > {output}"

# Merge filtered candidates.
rule merge_filtered_candidates:
    input: "filtered_candidates.tab", "merged_hardstops_per_bin.bed"
    output: "assembly_candidates.bed"
    # TODO: consider moving these parameters into config file
    params: sge_opts="", merge_distance="500", slop="10000", chromosome_lengths=config["reference"]["chromosome_lengths"]
    shell: "cut -f 1-3 {input} | sort -k 1,1 -k 2,2n | bedtools merge -i stdin -d {params.merge_distance} | bedtools slop -i stdin -g {params.chromosome_lengths} -b {params.slop} > {output}"

#
# Inaccessible regions
#

rule identify_inaccessible_regions:
    input: coverage="coverage.bed", excluded_regions="regions_to_exclude_as_inaccessible.bed"
    output: "inaccessible_regions.bed"
    params: sge_opts="", max_support=str(config["detection"]["max_inaccessible_support"])
    shell:
        "awk '$4 <= {params.max_support}' {input.coverage} | "
            "sed '/chrY/d;/chrEBV/d' | "
            "bedtools merge -i stdin -d 1000 | "
            "bedtools intersect -a stdin -b {input.excluded_regions} -v > {output}"

rule collect_regions_to_exclude_as_inaccessible_regions:
    input: "merged_hardstops_per_bin.bed", config["reference"]["gaps"], "filtered_candidates.tab", config["reference"]["centromeres"]
    output: "regions_to_exclude_as_inaccessible.bed"
    params: sge_opts=""
    shell: "cut -f 1-3 {input} | sort -k 1,1 -k 2,2n | bedtools merge -i stdin -d 1 > {output}"

#
# Hardstops (all classes)
#

# Filter hardstops to exclude reference gaps and small SV candidates. Then merge
# adjacent bins that pass filters.
rule filter_and_merge_adjacent_hardstop_bins:
    input: hardstops="hardstops_per_bin.bed", gaps=config["reference"]["gaps"], small_svs="filtered_candidates.tab"
    output: "merged_hardstops_per_bin.bed"
    params: sge_opts="-l mfree=1G", min_support=str(config["detection"]["min_hardstop_support"])
    shell:
        "awk '$4 > {params.min_support}' {input.hardstops} | "
            "bedtools window -w 1000 -a stdin -b {input.gaps} -v | "
            "bedtools window -w 1000 -a stdin -b {input.small_svs} -v | "
            "bedtools merge -i stdin -d 1 > {output}"

# Count hardstops per genomic bin.
rule count_hardstops_per_genomic_bin:
    input: hardstops="hardstop_breakpoints.bed", bins="hardstop_bins.bed"
    output: "hardstops_per_bin.bed"
    params: sge_opts="-l mfree=4G"
    shell: "bedtools intersect -a {input.bins} -b {input.hardstops} -sorted -c > {output}"

# Create hardstop breakpoints from hardstop locations (either left, right, or
# both). If a read is clipped on the left, use its start position as the
# breakpoint. If it is clipped on the right, use its end position. If a read is
# clipped from both sides, print two separate breakpoints using these same rules
# for left and right breakpoints.
rule create_hardstop_breakpoints:
    input: "hardstops.bed"
    output: "hardstop_breakpoints.bed"
    params: sge_opts="-l mfree=4G"
    shell: """awk 'OFS="\\t" {{
                  if ($6 == "left") {{ print $1,$2,$2 + 1,$4,$7,"left" }}
                  else if ($6 == "right") {{ print $1,$3 - 1,$3,$4,$8,"right" }}
                  else if ($6 == "both") {{ print $1,$2,$2 + 1,$4,$7,"left"; print $1,$3 - 1,$3,$4,$8,"right" }}
              }}' {input} | sort -k 1,1 -k 2,2n | awk '$1 != "chrY"' > {output}"""

# Collect gaps in one command
rule collect_hardstops:
    input: expand("hardstops_in_aligned_reads/{alignment_name}.bed", alignment_name=ALIGNMENT_NAMES)
    output: "hardstops.bed"
    params: sge_opts="-l mfree=4G"
    shell: "sort -k 1,1 -k 2,2n -m {input} > {output}"

# Parse CIGAR string of aligned reads for clipped alignments.
rule find_hardstops_in_aligned_reads:
    input: alignments=_get_bam_path_for_batch
    output: "hardstops_in_aligned_reads/{alignment_name}.bed"
    params: sge_opts="-l mfree=4G", mapping_quality_threshold=str(config["alignment"]["mapping_quality"]), min_clipping="500", bwlimit="20000"
    shell:
        "mkdir -p `dirname {output}`; "
        "mkdir -p {TMP_DIR}; "
        "scripts/mcst/hardstop {input} {params.mapping_quality_threshold} {params.min_clipping} {TMP_DIR}/hardstops.{wildcards.alignment_name}.bed; "
        "sort -k 1,1 -k 2,2n -o {TMP_DIR}/hardstops.{wildcards.alignment_name}.bed {TMP_DIR}/hardstops.{wildcards.alignment_name}.bed; "
        "rsync -W --bwlimit={params.bwlimit} --remove-source-files {TMP_DIR}/hardstops.{wildcards.alignment_name}.bed {output}"

rule create_genomic_bins:
    input: config["reference"]["chromosome_lengths"]
    output: "hardstop_bins.bed"
    params: sge_opts="", bin_size="500"
    shell: "bedtools makewindows -g {input} -w {params.bin_size} | sort -k 1,1 -k 2,2n > {output}"

#
# Small SVs (insertions and deletions)
#

# Plot candidate summary.
rule plot_candidate_summary:
    input: "sv_candidate_summary.tab"
    output: lengths="sv_candidate_lengths.pdf", support="sv_candidate_support.pdf"
    shell: "Rscript scripts/plot_SV_candidate_summary.R {input} {output.lengths} {output.support}"

# Summarize filtered candidates by event attributes.
rule summarize_filtered_candidates:
    input: expand("filtered_candidates_for_{event_type}.bed", event_type=EVENT_TYPES)
    output: "sv_candidate_summary.tab"
    shell: """awk 'OFS="\\t" {{ if (NR == 1) {{ print "event_type","mean_length","support" }} print $4,$5,$6 }}' {input} > {output}"""

# Summarize filtered candidates by event attributes.
rule combine_filtered_candidates:
    input: expand("filtered_candidates_for_{event_type}.bed", event_type=EVENT_TYPES)
    output: "filtered_candidates.tab"
    shell: "sort -k 1,1 -k 2,2n -m {input} | cut -f 1-4,6 > {output}"

# Filter candidates by support and coverage.
rule filter_candidates:
    input: "coverage_and_merged_support_for_{event_type}.bed"
    output: "filtered_candidates_for_{event_type}.bed"
    params:
        sge_opts="",
        min_support=str(config["detection"]["min_support"]),
        max_support=str(config["detection"]["max_support"]),
        min_length=str(config["detection"]["min_length"]),
        min_coverage=str(config["detection"]["min_coverage"]),
        max_coverage=str(config["detection"]["max_coverage"])
    shell:
        "awk '$4 >= {params.min_length} && $5 >= {params.min_support} && $5 <= {params.max_support} && $10 >= {params.min_coverage} && $10 <= {params.max_coverage}' {input} | "
            "bedtools merge -i stdin -d 1 -c 6,4,5 -o distinct,mean,mean > {output}"

# Annotate merged gap support with alignment coverage.
rule annotate_coverage_of_merged_gap_support:
    input: support="merged_support_for_{event_type}.bed", coverage="coverage.bed"
    output: "coverage_and_merged_support_for_{event_type}.bed"
    params: sge_opts=""
    shell: """bedtools intersect -a {input.support} -b {input.coverage} -sorted -wao | awk 'OFS="\\t" {{ if ($13 == ".") {{ $13 = 0 }} print }}' | groupBy -i stdin -g 1,2,3,4,5,6,7,8,9 -c 13 -o mean > {output}"""

# Merge gap support for each type of event.
rule merge_gap_support_from_aligned_reads:
    input: expand("aligned_reads_{{event_type}}/{alignment_name}.bed", alignment_name=ALIGNMENT_NAMES)
    output: "merged_support_for_{event_type}.bed"
    params: sge_opts="-l mfree=5G"
    shell: "sort -k 1,1 -k 2,2n -m --buffer-size=4G {input} | python scripts/PrintGapSupport.py /dev/stdin /dev/stdout | sort -k 1,1 -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6 -k 7,7 -k 8,8 -k 9,9 > {output}"

# Classify insertions and deletions into their own output files.
rule classify_gaps_in_aligned_reads:
    input: "gaps_in_aligned_reads/{alignment_name}.bed"
    output: "aligned_reads_{event_type}/{alignment_name}.bed"
    params: sge_opts=""
    shell: """awk '$4 == "{wildcards.event_type}"' {input} > {output}"""

# Parse CIGAR string of aligned reads for insertions and deletions.
rule find_gaps_in_aligned_reads:
    input: alignments=_get_bam_path_for_batch, reference=config["reference"]["assembly"]
    output: "gaps_in_aligned_reads/{alignment_name}.bed"
    params: sge_opts="-l mfree=6G -l disk_free=1G", mapping_quality_threshold=str(config["alignment"]["mapping_quality"]), bwlimit="20000", patterns_to_exclude="random|chrUn|chrY|chrM"
    shell:
        "mkdir -p `dirname {output}`; "
        "mkdir -p {TMP_DIR}; "
        "samtools view -F 0x4 -q {params.mapping_quality_threshold} {input.alignments} "
            """| grep -v -P "({params.patterns_to_exclude})" """
            "| python scripts/PrintGaps.py {input.reference} /dev/stdin --tsd 0 --condense 20 > {TMP_DIR}/gaps_in_aligned_reads.{wildcards.alignment_name}.bed; "
        "rsync -W --bwlimit={params.bwlimit} --remove-source-files {TMP_DIR}/gaps_in_aligned_reads.{wildcards.alignment_name}.bed {output}"

# Collect coverages from all alignments.
rule merge_coverage_per_batch:
    input: expand("coverage/{alignment_name}.bed", alignment_name=ALIGNMENT_NAMES)
    output: "coverage.bed"
    params: sge_opts="-l mfree=2G", bwlimit="20000"
    shell: """paste {input} | awk 'OFS="\\t" {{ sum = 0; for (i = 4; i <= NF; i++) {{ if (i % 4 == 0) {{ sum += $i }} }} print $1,$2,$3,sum }}' > {output}"""

# Calculate coverage from each batch.
rule calculate_coverage_per_batch:
    input: _get_bam_path_for_batch
    output: "coverage/{alignment_name}.bed"
    params: sge_opts="-l mfree=2G", bwlimit="20000"
    shell:
        "mkdir -p {TMP_DIR}; "
        "mkdir -p `dirname {output}`; "
        "scripts/mcst/coverage {TMP_DIR}/{wildcards.alignment_name}.bed -in {input}; "
        "rsync -W --bwlimit {params.bwlimit} --remove-source-files {TMP_DIR}/{wildcards.alignment_name}.bed {output}"
